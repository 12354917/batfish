block(`Route_rules) {
   alias_all(`libbatfish:Interface),
   alias_all(`libbatfish:Ip),
   alias_all(`libbatfish:Node),
   alias_all(`libbatfish:Route),
   clauses(`{
// BEGIN CODE

//BestConnectedRoute(node, network, nextHop, nextHopIp, admin, cost, protocol) <-
BestConnectedRoute(route),
   Route(route),
   InterfaceRoute_constructor[node, network, nextHopInt, protocol] = route,
   Route_admin[route] = admin,
   Route_cost[route] = cost,
   Route_network[route] = network,
   Route_nextHopInt[route] = nextHopInt,
   Route_node[route] = node,
   Route_protocol[route] = protocol
<-
   ConnectedRoute(node, network, nextHopInt),
   SetNodeVendor(node, vendor),
   AdministrativeDistance[vendor, protocol] = admin, 
   cost = 0,
   protocol = RoutingProtocol_CONNECTED[].

BestPerProtocolRoute(route) <-
   BestConnectedRoute(route) ;
   BestStaticRoute(route).

BestStaticRoute(route) <-
   StaticIntRoute(route) ;
   StaticRoute(route).

ConnectedRoute(node, network, interface) <-
   IpReadyInt(node, interface, ip, prefix_length),
   NetworkOf[ip, prefix_length] = network.

InstalledRoute(route) <-
   MinCostRoute(route).

InterfaceRoute(route) <-
   Route_nextHopInt[route] = _.

LongestPrefixNetworkMatch(node, ip, matchNet) <-
   LongestPrefixNetworkMatchPrefixLength[node, ip] = maxLength,
   NetworkMatch(node, ip, matchNet, maxLength).

LongestPrefixNetworkMatchPrefixLength[node, ip] = maxLength <-
   agg<<maxLength = max(matchLength)>>
      NetworkMatch(node, ip, _, matchLength).
      
MinAdmin[node, network] =  minAdmin <-
   agg<<minAdmin = min(admin)>>
      BestPerProtocolRoute(route),
      Route_admin[route] = admin,
      Route_network[route] = network,
      Route_node[route] = node.

MinAdminRoute(route) <-
   minAdmin = MinAdmin[node, network],
   BestPerProtocolRoute(route),
   Route_admin[route] = minAdmin,
   Route_network[route] = network,
   Route_node[route] = node.
   
MinCost[node, network] =  minCost <-
   agg<<minCost = min(cost)>>
      MinAdminRoute(route),
      Route_cost[route] = cost,
      Route_network[route] = network,
      Route_node[route] = node.

MinCostRoute(route) <-
   MinAdminRoute(route),
   minCost = MinCost[node, network],
   Route_cost[route] = minCost,
   Route_network[route] = network,
   Route_node[route] = node.

NetworkMatch(node, ip, matchNet, matchLength) <-
   Ip_address(ip:address),
   Network_address[matchNet] = matchNet_start,
   Network_prefix_length[matchNet] = matchLength,
   Network_end[matchNet] = matchNet_end,
   InstalledRoute(route),
   Route_network[route] = matchNet,
   Route_node[route] = node,
   matchNet_start <= address <= matchNet_end.
      
Route_nextHop[route] = nextHop <-
   InstalledRoute(route),
   Route_nextHopIp[route] = nextHopIp,
   HasIp(nextHop, nextHopIp).
Route_nextHop[route] = nextHop <-
   nextHop = Node_NONE[],
   InstalledRoute(route),
   Route_nextHopIp[route] = nextHopIp,
   !HasIp(_, nextHopIp).
Route_nextHop[route] = nextHop <-
   nextHop = Node_NONE[],
   InstalledRoute(route),
   Route_nextHopIp[route] = Ip_ZERO[].

RoutingProtocol_AGGREGATE[] = x <-
   RoutingProtocol_name(x:"aggregate").   

RoutingProtocol_BGP[] = x <-
   RoutingProtocol_name(x:"bgp").

RoutingProtocol_CONNECTED[] = x <-
   RoutingProtocol_name(x:"connected").

RoutingProtocol_IBGP[] = x <-
   RoutingProtocol_name(x:"ibgp").

RoutingProtocol_OSPF[] = x <-
   RoutingProtocol_name(x:"ospf").

RoutingProtocol_OSPF_IA[] = x <-
   RoutingProtocol_name(x:"ospfIA").

RoutingProtocol_OSPF_E2[] = x <-
   RoutingProtocol_name(x:"ospfE2").

RoutingProtocol_STATIC[] = x <-
   RoutingProtocol_name(x:"static").

SetStaticIntRoute(node, network, nextHopIp, nextHopInt, admin) <-
   SetStaticIntRoute_flat(node, network_start, network_end, prefix_length, nextHopIp, nextHopInt, admin),
   Network_constructor[network_start, network_end, prefix_length] = network.

SetStaticRoute(node, network, nextHopIp, admin) <-
   SetStaticRoute_flat(node, network_start, network_end, prefix_length, nextHopIp, admin),
   Network_constructor[network_start, network_end, prefix_length] = network.

// static route with next hop interface
StaticIntRoute(route),
   Route(route),
   InterfaceRoute_constructor[node, network, nextHopInt, protocol] = route,
   Route_admin[route] = admin,
   Route_cost[route] = cost,
   Route_network[route] = network,
   Route_nextHopIp[route] = nextHopIp,
   Route_nextHopInt[route] = nextHopInt,
   Route_node[route] = node,
   Route_protocol[route] = protocol
<-
   SetStaticIntRoute(node, network, nextHopIp, nextHopInt, admin),
   cost = 0,
   protocol = RoutingProtocol_STATIC[].

// static route with next hop ip
StaticRoute(route),
   Route(route),
   Route_constructor[node, network, nextHopIp, protocol] = route,
   Route_admin[route] = admin,
   Route_cost[route] = cost,
   Route_network[route] = network,
   Route_nextHopIp[route] = nextHopIp,
   Route_node[route] = node,
   Route_protocol[route] = protocol
<-
   LongestPrefixNetworkMatch(node, nextHopIp, _),
   SetStaticRoute(node, network, nextHopIp, admin),
   cost = 0,
   protocol = RoutingProtocol_STATIC[].

/*
// exact match
StaticRoute(node, network, nextHop, nextHopIp, admin) <-
   LongestPrefixNetworkMatch(node, staticNextHopIp, matchNet),
   SetStaticRoute(node, network, staticNextHopIp, admin),
   InstalledRoute(node, matchNet, _, _, _, _, _),
   nextHopIp = staticNextHopIp,
   SetIpInt(nextHop, _, staticNextHopIp, prefixLength),
   NetworkOf[staticNextHopIp, prefixLength] = matchNet.
*/

lang:compiler:disableError:NEGATION_RECURSION[] = true.
lang:compiler:disableWarning:NEGATION_RECURSION[] = true.

lang:compiler:disableError:AGGREGATE_RECURSION[] = true.
lang:compiler:disableWarning:AGGREGATE_RECURSION[] = true.

// END CODE
   })
} <-- .

