block(`Route) {
   alias_all(`libbatfish:Interface),
   alias_all(`libbatfish:Ip),
   alias_all(`libbatfish:Node),
   alias_all(`libbatfish:PolicyMap),
   export(`{
// BEGIN CODE

/// [AdministrativeDistance[protocol] = distance] =
///   The administrative distance of routing protocol [protocol] for vendor
///   [vendor] is [distance].
AdministrativeDistance[vendor, protocol] = distance ->
   Vendor(vendor),
   RoutingProtocol(protocol),
   int(distance).

BestConnectedRoute(node, network, nextHop, nextHopIp, admin, cost, protocol) ->
   Node(node),
   Network(network),
   Node(nextHop),
   Ip(nextHopIp),
   int(admin),
   int(cost),   
   RoutingProtocol(protocol).

/// [BestPerProtocol(node, network, nextHop, nextHopIp, admin, cost, protocol)] =
///   Node [Node] has a route to network [network] through next hop [nextHop]
///   at ip address [nextHopIp], with minimal administrative distance [admin],
///   and cost [cost], received using routing protocol [protocol], and that is
///   optimal before cost is taken into account.
BestPerProtocolRoute(node, network, nextHop, nextHopIp, admin, cost, protocol) ->
   Node(node),
   Network(network),
   Node(nextHop),
   Ip(nextHopIp),
   int(admin),
   int(cost),   
   RoutingProtocol(protocol).

BestStaticRoute(node, network, nextHop, nextHopIp, admin, cost, protocol) ->
   Node(node),
   Network(network),
   Node(nextHop),
   Ip(nextHopIp),
   int(admin),
   int(cost),   
   RoutingProtocol(protocol).

/// [ConnectedRoute(node, network)] =
///   Node [node] has a directly connected route to network [network] through [interface].
ConnectedRoute(node, network, interface) ->
   Node(node),
   Network(network),
   Interface(interface).

/// [InstalledRoute(node, network, nextHop, nextHopIp, admin, cost, protocol)] =
///   Node [node] has a route to network [network] with next hop [nextHop] at
///   ip address [nextHopIp], with administrative distance [admin],
///   protocol-specific cost [cost], received through protocol [protocol].
InstalledRoute(node, network, nextHop, nextHopIp, admin, cost, protocol) ->
   Node(node),
   Network(network),
   Node(nextHop),
   Ip(nextHopIp),
   int(admin),
   int(cost),
   RoutingProtocol(protocol).

LongestPrefixNetworkMatch(node, ip, matchNet) ->
   Node(node),
   Ip(ip),
   Network(matchNet).

LongestPrefixNetworkMatchPrefixLength[node, ip] = maxLength ->
   Node(node),
   Ip(ip),
   int(maxLength).
   
/// [MinAdmin[node, network] = minAdmin] =
///   The minimum administrative distance of any route from node [node] to
///   network [network] is [minAdmin].
MinAdmin[node, network] =  minAdmin ->
   Node(node),
   Network(network),
   int(minAdmin).

/// [MinAdminRoute(node, network, nextHop, nextHopIp, minAdmin, cost, protocol)] =
///   Node [Node] has a route to network [network] through next hop [nextHop]
///   at ip address [nextHopIp], with minimal administrative distance
///   [minAdmin], and cost [cost], received using routing protocol [protocol].
MinAdminRoute(node, network, nextHop, nextHopIp, minAdmin, cost, protocol) ->
   Node(node),
   Network(network),
   Node(nextHop),
   Ip(nextHopIp),
   int(minAdmin),
   int(cost),   
   RoutingProtocol(protocol).

/// [MinCost[node, network, protocol] = minCost] =
///   The minimum cost of any best pre-cost route from node
///   [node] to network [network] is [minCost].
MinCost[node, network] =  minCost ->
   Node(node),
   Network(network),
   int(minCost).

/// [MinCostRoute(node, network, nextHop, nextHopIp, admin, minCost, protocol)] =
///   Node [Node] has a route to network [network] through next hop [nextHop]
///   at ip address [nextHopIp], with minimal administrative distance [admin]
///   and minimal cost for that administrative distance [minCost], received
///   using routing protocol [protocol].
MinCostRoute(node, network, nextHop, nextHopIp, admin, minCost, protocol) ->
   Node(node),
   Network(network),
   Node(nextHop),
   Ip(nextHopIp),
   int(admin),
   int(minCost),   
   RoutingProtocol(protocol).

NetworkMatch(node, ip, matchNet, matchLength) ->   
   Node(node),
   Ip(ip),
   Network(matchNet),
   int(matchLength).

/// [RoutingProtocol(x)] =
///   [x] is routing protocol.
RoutingProtocol(x),
   RoutingProtocol_name(x:n)
   ->
   string(n).

RoutingProtocol_AGGREGATE[] = x ->
   RoutingProtocol(x).

RoutingProtocol_BGP[] = x ->
   RoutingProtocol(x).

RoutingProtocol_CONNECTED[] = x ->
   RoutingProtocol(x).

RoutingProtocol_IBGP[] = x ->
   RoutingProtocol(x).

RoutingProtocol_OSPF[] = x ->
   RoutingProtocol(x).

RoutingProtocol_OSPF_E2[] = x ->
   RoutingProtocol(x).

RoutingProtocol_OSPF_IA[] = x ->
   RoutingProtocol(x).

RoutingProtocol_STATIC[] = x ->
   RoutingProtocol(x).

/// [SetStaticRoute(node, network, nextHopIp, admin)] =
///   Node [node] has a static route to network [network] with next hop ip
///   [nextHopIp] and administrative distance [admin].
SetStaticRoute(node, network, nextHopIp, admin) ->
   Node(node),
   Network(network),
   Ip(nextHopIp),
   int(admin).
   
SetStaticRoute_flat(node, network_start, network_end, prefix_length, nextHopIp, admin) ->
   Node(node),
   int(network_start),
   int(network_end),
   int(prefix_length),
   Ip(nextHopIp),
   int(admin).
   
/// [StaticRoute(node, network, nextHop, nextHopIp, admin)] =
///   Node [node] has a static route to network [network] with next hop
///   [nextHop] at ip address [nextHopIp], administrative distance [admin], and
///   hop count [hopCount].
StaticRoute(node, network, nextHop, nextHopIp, admin) ->
   Node(node),
   Network(network),
   Node(nextHop),
   Ip(nextHopIp),
   int(admin).

// END CODE
   })
} <-- .

