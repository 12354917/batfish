# This demo operates over the example test rigs in the batfish repository.
# It assumes that it runs from the top-level directory in the repository.

# To get relevant shell commands, do:
## % source tools/batfish_function.sh

# The client runs against the batfish service, hosted locally or on a remote server. 
# To start the service locally, do the following in a new shell: 
## % source tools/batfish_functions.sh
## % allinone -runmode interactive
# Then run the client:
## % batfish_pyclient -c demo-python/commands -s <server>
## replace <server> with service location (e.g., "localhost" or "www.batfish.org") 

echo # load the testing 
command bf_init_testrig("test_rigs/example")

echo #####################
echo # our logical representation of the network that can be queried in various ways. we have many queries and can write more

echo # E.g., we can ask questions on adjacencies to ensure that they are as expected (i.e., interfaces are properly configured)
command bf_answer_type("neighbors")

echo # we can also ask for protocol-level adjacencies to ensure that protocol sessions are configured correctly
command bf_answer_type("neighbors", neighborType=["ebgp"])

echo ##############
echo # we can also do other simple checks based on best practices of the network

echo # E.g., we can check if all interface ips are unique
command bf_answer_type("uniqueipassignments")

echo # Or that all loopbacks are announced within OSPF
command bf_answer_type("ospfloopbacks")

echo ################
echo # going deeper, we can ask questions about data flow, i.e., the end-to-end impact of all configuration snippets

echo # E.g., we can see how host1 reaches a given IP address 
echo # this query will take time if the dataplane has not been comptued before
command bf_answer_type("traceroute", ingressNode="host1", dstIp="1.0.2.2")
echo # --> unlike a regular traceroute we show multipath and interface information

echo # Or, we can ensure that the dns server on host1 (2.128.0.101) is reachable using using protocol-specific traceroutes
command bf_answer_type("traceroute", ingressNode="as2border1", dstIp="2.128.0.101", dstPort=53, ipProtocol="UDP")

echo ################
echo # while testing/emulation can do the above, we alone can be comprehensive 

echo # E.g., we can find *all* (starting node, packet header) combinations for which the DNS server is unreachable
command bf_answer_type("reachability", dstIps=["2.128.0.101"], dstPorts=[53], ipProtocols=["UDP"], actions=["drop"])
echo # --> the output shows outsiders with spoofed source addresses cannot reach the DNS server (good)
echo # --> it also shows that a bad ACL on host2 is blocking access (bad)
echo # we can run a similar query to ensure that the SSH server on host2 is accessible

echo # But suppose we want to ensure that *only* ssh traffic can reach host2 
command bf_answer_type("reachability", actions=["ACCEPT"], dstIps=["2.128.1.101"], notDstPorts=[22], notIpProtocols=["TCP"])
echo # --> all good! hard to guarantee with testing but easy for us

echo # another example: Ensure that outsiders can *never* reach the SSH server
echo # we have ACLs on as2's border routers to prevent this. let's test that things are correctly implemented:
command bf_answer_type("reachability", actions=["ACCEPT"], dstPorts=[22], dstIps=["2.128.1.101"], ingressNodeRegex="as(1|3)border1", ipProtocols=["TCP"])
echo # --> buggy ACL on as2border2!

echo #############
echo # comparing two sets of configs (e.g., current + planned) is a powerful debugging aid

echo # initialize the delta testrig
command bf_init_testrig("test_rigs/example-with-delta", doDelta=True)

echo # any query can be executed differentially, to see what changed
command bf_answer_type("neighbors", differential=True)

echo # a particularly powerful query: reachability diff between two testrigs
command bf_answer_type("reachability", type="reduced")
echo # --> any collateral damage is easy to see

echo #############
echo # fault-tolerance can be ensured by studying the impact of failures

echo # E.g., this command creates a network view after an interface failure
command bf_init_environment(interfaceBlacklist=[{"hostname" : "as2border2", "interface" : "FastEthernet0/0"}])

echo # we can see if reachability changes at all after this failure
command bf_answer_type("reachability", type="reduced")
echo # --> any lack of fault tolerance is easy to see

echo ##############
echo # finally, sanity checking can be done in the data plane too (e.g., valley-free routing in the DC, number of hops)

echo # a powerful query: multipath consistency. 
command bf_answer_type("reachability", type="multipath")
echo # --> will catch hard-to-debug, bad interactions between routing and ACLs
